#第9章:异常
[TOC]
```
本章目的:异常的作用非常强大,可以提高程序可读性和可靠性,可维护性.本章将介绍有效使用异常指导原则
```
###第57条:只针对异常的情况才使用异常
- 举例：
```
如果有一天你看到下面的代码，请与写这段代码的程序员保持工作距离。
```
```java
// Horrible abuse of exception. Don't ever do this
try{
	int i =0;
    while(true)
    	range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){
}
```
Note:
```
这段代码写的很糟糕。这段代码使用数组抛出异常的手段来企图终止无限循环的目的，是非常愚蠢的想法。
这里的Excpetion并不具有真正被使用的原因(55)
```
```
写这段代码的人，可能企图使用Java错误判断机制来提高性能。避免VM对每次数组访问检查越界情况。但是结果适得其反
```

#######这样做的三个缺点
```
1. 异常机制的设计初衷是用于不正常的情形，所以VM可能并不会不断的对其进行优化。
现代的JVM实现，基于异常的模式比标准模式要慢得多。
```
```
2. 把代码放在try-catch块中，反而阻止了现代JVM实现本来可能要执行的某些特定优化
```
```
3. 可读性大大的下降，也增加了调试复杂性。同时对数组进行遍历的标准模式并不会导致冗余检查。
```

######从案例中得到警告
```
异常应该只用于异常的情况下，它们永远也不应该用于正常的控制流。
```
```
作为标准程序员，应该优先使用标准的，容易理解的模式，而不是那么声称可以提高性能的，弄巧成拙的方法。
```

#####对API设计的启发
```
设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。
```
```
如果类具有“状态相关”的方法，即只有在特定的不可预知的条件下被调用的方法，类往往也会提供一个单独的“状态测试”方法。
比如：Iterator接口有一个“状态相关”的next方法，和相应的状态测试方法hasNext().使用传统的for循环遍历代码
```
```java
for(Iterator< Foo > i = collection.iterator();i.hasNext();){
	Foo foo = i.next();
    ....
}
```
```
如果Iterator缺少hasNext方法，客户端使用可能被迫改为使用异常来结束代码
```
```java
// Do not use this hideous code for iteration over a colleation!
try{
	Iterator< Foo > i = collection.iterator();
    while(true){
    	Foo foo = i.next();
        ....
    }
}catch(NoSuchElementException e){

}
```
Note:
```
这段代码就和我们开始举的例子差不多了。是段非常糟糕的代码
```

#####总结
```
异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使客户端必须这么做的API。
```

###第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常