#第9章:异常
[TOC]
```
本章目的:异常的作用非常强大,可以提高程序可读性和可靠性,可维护性.本章将介绍有效使用异常指导原则
```
###第57条:只针对异常的情况才使用异常
- 举例：
```
如果有一天你看到下面的代码，请与写这段代码的程序员保持工作距离。
```
```java
// Horrible abuse of exception. Don't ever do this
try{
	int i =0;
    while(true)
    	range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){
}
```
Note:
```
这段代码写的很糟糕。这段代码使用数组抛出异常的手段来企图终止无限循环的目的，是非常愚蠢的想法。
这里的Excpetion并不具有真正被使用的原因(55)
```
```
写这段代码的人，可能企图使用Java错误判断机制来提高性能。避免VM对每次数组访问检查越界情况。但是结果适得其反
```

#######这样做的三个缺点
```
1. 异常机制的设计初衷是用于不正常的情形，所以VM可能并不会不断的对其进行优化。
现代的JVM实现，基于异常的模式比标准模式要慢得多。
```
```
2. 把代码放在try-catch块中，反而阻止了现代JVM实现本来可能要执行的某些特定优化
```
```
3. 可读性大大的下降，也增加了调试复杂性。同时对数组进行遍历的标准模式并不会导致冗余检查。
```

######从案例中得到警告
```
异常应该只用于异常的情况下，它们永远也不应该用于正常的控制流。
```
```
作为标准程序员，应该优先使用标准的，容易理解的模式，而不是那么声称可以提高性能的，弄巧成拙的方法。
```

#####对API设计的启发
```
设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。
```
```
如果类具有“状态相关”的方法，即只有在特定的不可预知的条件下被调用的方法，类往往也会提供一个单独的“状态测试”方法。
比如：Iterator接口有一个“状态相关”的next方法，和相应的状态测试方法hasNext().使用传统的for循环遍历代码
```
```java
for(Iterator< Foo > i = collection.iterator();i.hasNext();){
	Foo foo = i.next();
    ....
}
```
```
如果Iterator缺少hasNext方法，客户端使用可能被迫改为使用异常来结束代码
```
```java
// Do not use this hideous code for iteration over a colleation!
try{
	Iterator< Foo > i = collection.iterator();
    while(true){
    	Foo foo = i.next();
        ....
    }
}catch(NoSuchElementException e){

}
```
Note:
```
这段代码就和我们开始举的例子差不多了。是段非常糟糕的代码
```

#####总结
```
异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使客户端必须这么做的API。
```

###第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
#####Java语言提供三种可抛出结构
```
1. 受检的异常
```
```
2. 运行时异常
```
```
3. 错误
```
#####根据一般性原则选择三种抛出结构
#######受检异常或未受检异常选择原则
```
主要原则：如果期望调用者能够适当地恢复，请使用受检的异常。
```
```
通过抛出受检的异常，强迫调用者在一个catch子句中处理改异常，或者将它传播出去。
API设计者让API用户面对受检的异常，强制用户从这个异常中恢复
```
#######未受检的可抛出结构：运行是异常和错误
```
如果程序抛出未受检异常或者错误，往往属于不可恢复的，继续执行下去有害无益。
```
```
运行时异常表明编程错误。大多数运行时异常都表示前提违例。也就是说API的客户没有遵守API规范建立的约定。
比如:ArrayIndexOutOfBoundsException表明数组下标值超出0~(N-1)
```
```
错误的发生，往往表示资源不足，约束失败，或者其他使程序无法继续执行的条件。请不要在实现任何新的Error子类
```
```
对于可以实现所有的未受检的抛出结构都应该直接或者间接是RuntimeException的子类
```

#####总结
```
对于可恢复的情况，使用受检的异常；对于程序错误，使用运行时异常。当然某些情况可能不好区分
```
- 举例：
```
某程序分配一块不合理的过大的数组，导致资源不足，如果资源短缺是由于临时需要太大，则这种情况是可以恢复的，
API设计者允许其恢复，则使用受检的异常。如果不允许，使用运行时异常。
如果不清楚是否可恢复，最好使用未受检的异常(59)
```

```
异常是一个有意义的对象，可以为它定义任意的方法，这些方法主要用途是为了捕捉异常的代码而提供额外的信息。
特别是引发这个异常条件的信息。
```
```
受检方法往往指明可恢复的条件，所以，对于这样的异常，提供一些辅助方法是非常重要的，通过这些方法，调用者可以获得有助于恢复的信息。
```
- 举例：
```
用于支付商品时，由于余额不足，发生受检异常，则这个受检异常应该提供客户查询所缺的费用的余额方法。
```

###第59条：避免不必要地使用受检的异常