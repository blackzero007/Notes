#第9章:异常
[TOC]
```
本章目的:异常的作用非常强大,可以提高程序可读性和可靠性,可维护性.本章将介绍有效使用异常指导原则
```
###第57条:只针对异常的情况才使用异常
- 举例：
```
如果有一天你看到下面的代码，请与写这段代码的程序员保持工作距离。
```
```java
// Horrible abuse of exception. Don't ever do this
try{
	int i =0;
    while(true)
    	range[i++].climb();
}catch(ArrayIndexOutOfBoundsException e){
}
```
Note:
```
这段代码写的很糟糕。这段代码使用数组抛出异常的手段来企图终止无限循环的目的，是非常愚蠢的想法。
这里的Excpetion并不具有真正被使用的原因(55)
```
```
写这段代码的人，可能企图使用Java错误判断机制来提高性能。避免VM对每次数组访问检查越界情况。但是结果适得其反
```

#######这样做的三个缺点
```
1. 异常机制的设计初衷是用于不正常的情形，所以VM可能并不会不断的对其进行优化。
现代的JVM实现，基于异常的模式比标准模式要慢得多。
```
```
2. 把代码放在try-catch块中，反而阻止了现代JVM实现本来可能要执行的某些特定优化
```
```
3. 可读性大大的下降，也增加了调试复杂性。同时对数组进行遍历的标准模式并不会导致冗余检查。
```

######从案例中得到警告
```
异常应该只用于异常的情况下，它们永远也不应该用于正常的控制流。
```
```
作为标准程序员，应该优先使用标准的，容易理解的模式，而不是那么声称可以提高性能的，弄巧成拙的方法。
```

#####对API设计的启发
```
设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。
```
```
如果类具有“状态相关”的方法，即只有在特定的不可预知的条件下被调用的方法，类往往也会提供一个单独的“状态测试”方法。
比如：Iterator接口有一个“状态相关”的next方法，和相应的状态测试方法hasNext().使用传统的for循环遍历代码
```
```java
for(Iterator< Foo > i = collection.iterator();i.hasNext();){
	Foo foo = i.next();
    ....
}
```
```
如果Iterator缺少hasNext方法，客户端使用可能被迫改为使用异常来结束代码
```
```java
// Do not use this hideous code for iteration over a colleation!
try{
	Iterator< Foo > i = collection.iterator();
    while(true){
    	Foo foo = i.next();
        ....
    }
}catch(NoSuchElementException e){

}
```
Note:
```
这段代码就和我们开始举的例子差不多了。是段非常糟糕的代码
```

#####总结
```
异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使客户端必须这么做的API。
```

###第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
#####Java语言提供三种可抛出结构
```
1. 受检的异常
```
```
2. 运行时异常
```
```
3. 错误
```
#####根据一般性原则选择三种抛出结构
#######受检异常或未受检异常选择原则
```
主要原则：如果期望调用者能够适当地恢复，请使用受检的异常。
```
```
通过抛出受检的异常，强迫调用者在一个catch子句中处理改异常，或者将它传播出去。
API设计者让API用户面对受检的异常，强制用户从这个异常中恢复
```
#######未受检的可抛出结构：运行是异常和错误
```
如果程序抛出未受检异常或者错误，往往属于不可恢复的，继续执行下去有害无益。
```
```
运行时异常表明编程错误。大多数运行时异常都表示前提违例。也就是说API的客户没有遵守API规范建立的约定。
比如:ArrayIndexOutOfBoundsException表明数组下标值超出0~(N-1)
```
```
错误的发生，往往表示资源不足，约束失败，或者其他使程序无法继续执行的条件。请不要在实现任何新的Error子类
```
```
对于可以实现所有的未受检的抛出结构都应该直接或者间接是RuntimeException的子类
```

#####总结
```
对于可恢复的情况，使用受检的异常；对于程序错误，使用运行时异常。当然某些情况可能不好区分
```
- 举例：
```
某程序分配一块不合理的过大的数组，导致资源不足，如果资源短缺是由于临时需要太大，则这种情况是可以恢复的，
API设计者允许其恢复，则使用受检的异常。如果不允许，使用运行时异常。
如果不清楚是否可恢复，最好使用未受检的异常(59)
```

```
异常是一个有意义的对象，可以为它定义任意的方法，这些方法主要用途是为了捕捉异常的代码而提供额外的信息。
特别是引发这个异常条件的信息。
```
```
受检方法往往指明可恢复的条件，所以，对于这样的异常，提供一些辅助方法是非常重要的，通过这些方法，调用者可以获得有助于恢复的信息。
```
- 举例：
```
用于支付商品时，由于余额不足，发生受检异常，则这个受检异常应该提供客户查询所缺的费用的余额方法。
```

###第59条：避免不必要地使用受检的异常
```
受检异常是Java程序设计语言的一项很好的特性，强迫程序员程序处理异常的条件，大大增加可靠性。
```
```
但是，过分使用受检异常，会使API使用起来非常不方便。所以，请避免不必要的受检异常
```

#####受检的异常使用原则
#######使用条件
```
如果下面两个条件有任何一个不成立,则更适合使未受检的异常
```
```
1. 正确地使用API并不能保证这种异常条件的产生
```
```
2. 并且一旦产生异常，使用API程序员的程序可以理解采取有用的动作.这种负担被认为是正当的
```
-  举例:
```java
} catch(TheCheckedException e){
	throw new AssertionError(); // Can't happen
}
```
```java
} catch(TheCheckedException e){
	e.printStackTrace(); // Oh well, we close
    System.exit(1);
}
```
Note:
```
在实践中,catch块几乎总是具有断言(assertion)失败的特征.异常受检的本质并没有为程序员提供任何好处,反而需要付出努力,让程序变的复杂.
```

#####受检的异常后果
```
被一个方法单独抛出的受检异常,会给程序员带来非常高的负担.如果这个方法中还有其他的受检异常,对使用方法的程序员来说,
每个异常可能都要加一个catch块.
```

#####将受检的异常变成未受检的异常
```
把这个抛出异常的方法分成两个方法,其中一个方法返回一个boolean,表明是否应该抛出异常.
```
```java
// Invocation with checked exception
try{
	obj.action(args);
}catch(TheCheckedException e){
	// handle exceptional condition
}
```
```
重构成
```
```java
// Invocation with state-testing method and unchecked exception
if(obj.actionPermitted(args)){
	obj.action(args);
}else{
	//handle exceptional condition
}
```
Note:
```
这种重构可能并不总是恰当的.但是如果可行,会使API使用舒服.
```

#####总结
```
本条目提到的重构,可能在本质上等同于"状态测试方法"(57),并且,同样的告诫依然有效:
如果对象在缺少外部同步的情况下被并发访问,或者可被外界改变状态,这种重构方式将是不恰当的.
```
```
如果单独的actionPermitted方法必须重复action方法的工作,处于性能,这种API重构不值得做.
```

###第60条:优先使用标准的异常
```
讨论常见的可重用异常
```
```
Java平台类库提供了一组基本的未受检异常,满足了大多数API的异常抛出需求.
```

#####专家级程序员与缺乏经验的程序员最大的区别
```
专家追求并且通常也能实现高度的代码重用.代码重用是值得提倡的,异常代码也不例外.
```
#####重用现有的异常的好处
```
1. 它会使你的API更加容易学习和使用,你的API属于习惯用法
```
```
2. 对于使用这些API的程序员而言,可读性会更好,因为它不会出现很多程序员不熟悉的异常.
```

#####Java类库中的异常

####### 大多数的方法错误调用,都可以使用异常:IllegalArgumentException,IllegalStateException
```
1. 非法参数异常:IllegalArgumentException

当调用这传递的参数不合适时,产生这个异常.比如:一个参数代表"某个动作执行次数",但程序却出入一个负数.
```
```
2. 非法状态异常:IllegalStateException

如果对象的状态使用非法,产生这个异常.比如:在某个对象被正确初始化之前,调用者企图使用这个对象,则应该抛出这个异常.
```

####### 还有一些标准异常被用于特定情况下的非法参数和非法状态
```
1. 如果某个方法不允许传入null值的参数,习惯抛出NullPointException,而不是IllegalArgumentException
```
```
2. 如果序列的下标参数传递越界只,习惯抛出IndexOutOfBoundsException,而不是IllegalArgumentException
```

#######其他常用的异常
```
1. 并发状态异常:ConcurrentModificationException

如果某个对象被设计成单线程或者与外部同步机制配合使用,一旦发现被并发修改,则应该抛出ConcurrentModificationException异常
```
```
2. 不支持操作的异常:UnsupportedOperationException

绝大多数对象都会支持它们实现的所有方法.但是可能由于继承某个接口,不得不实现这个接口的某些方法,但是又不想被调用,可以使用
```

#####最常见的可重用异常
|异常|使用场合|
|:---:|:---:|
|IllegalArgumentException|非null参数值的不正确|
|IllegalStateException|对方法调用而言,对象状态不合适|
|NullPointerException|禁止使用null的情况下参数值为null|
|IndexOutOfBoundsException|下标参数值越界|
|ConcurrentModificationException|禁止并发修改的情况下,检查到对象并发修改|
|UnsupportedOperationException|
|IllegalAccessException|
